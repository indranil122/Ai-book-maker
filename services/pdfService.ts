import { jsPDF } from "jspdf";
import { Book } from "../types";
import { marked } from 'marked';

// A custom renderer for marked that strips all formatting and outputs plain text.
const plainTextRenderer = new marked.Renderer();
plainTextRenderer.strong = (text) => text;
plainTextRenderer.em = (text) => text;
plainTextRenderer.codespan = (text) => text;
plainTextRenderer.br = () => '\n';
plainTextRenderer.del = (text) => text;
plainTextRenderer.link = (_href, _title, text) => text;
plainTextRenderer.image = (_href, _title, text) => text;
plainTextRenderer.text = (text) => text;
plainTextRenderer.paragraph = (text) => text + '\n\n';
plainTextRenderer.html = (_html) => '';
plainTextRenderer.heading = (text, _level) => text + '\n\n';
plainTextRenderer.hr = () => '\n---\n';
plainTextRenderer.list = (body, _ordered, _start) => body + '\n';
plainTextRenderer.listitem = (text) => `â€¢ ${text}\n`;
plainTextRenderer.checkbox = (checked) => (checked ? '[x] ' : '[ ] ');
plainTextRenderer.blockquote = (quote) => `> ${quote}\n\n`;
plainTextRenderer.code = (code, _infostring, _escaped) => `${code}\n\n`;

marked.setOptions({ renderer: plainTextRenderer });


export const pdfService = {
  generatePdf: (book: Book) => {
    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    
    doc.setFont("times", "normal");

    // 1. COVER PAGE
    if (book.coverImage) {
      try {
        let format = "JPEG";
        if (book.coverImage.startsWith("data:image/png")) {
            format = "PNG";
        }
        doc.addImage(book.coverImage, format, 0, 0, pageWidth, pageHeight);
      } catch (e) {
        console.warn("Could not add cover image to PDF", e);
      }
      doc.addPage();
    }

    // 2. TITLE PAGE
    doc.setFont("times", "bold");
    doc.setFontSize(28);
    doc.text(book.title, pageWidth / 2, pageHeight / 3, { align: "center", maxWidth: pageWidth - 40 });
    
    doc.setFont("times", "italic");
    doc.setFontSize(16);
    doc.text(`by ${book.author}`, pageWidth / 2, (pageHeight / 3) + 20, { align: "center" });
    
    doc.setFont("times", "normal");
    doc.setFontSize(12);
    doc.text(`${book.genre} | ${book.tone}`, pageWidth / 2, pageHeight - 30, { align: "center" });
    doc.text(`Generated by Lumina AI`, pageWidth / 2, pageHeight - 20, { align: "center" });
    
    doc.addPage();

    // 3. CHAPTERS
    const margin = 20;
    const maxLineWidth = pageWidth - (margin * 2);
    const lineHeight = 7;
    
    book.chapters.forEach((chapter, index) => {
      // Chapter Title
      doc.setFont("times", "bold");
      doc.setFontSize(20);
      doc.text(chapter.title, pageWidth / 2, margin + 10, { align: "center" });
      
      doc.setFont("times", "normal");
      doc.setFontSize(12);

      let cursorY = margin + 30;

      // Convert chapter markdown to clean plain text
      const plainTextContent = marked.parse(chapter.content) as string;
      const paragraphs = plainTextContent.split('\n');
      
      paragraphs.forEach(para => {
         if (!para.trim()) {
             cursorY += lineHeight / 2;
             return;
         }
         
         const lines = doc.splitTextToSize(para, maxLineWidth);
         
         lines.forEach((line: string) => {
             if (cursorY > pageHeight - margin) {
                 doc.addPage();
                 cursorY = margin + 10;
             }
             
             doc.text(line, margin, cursorY, { align: "justify", maxWidth: maxLineWidth });
             cursorY += lineHeight;
         });
      });

      if (index < book.chapters.length - 1) {
          doc.addPage();
      }
    });

    doc.save(`${book.title.replace(/\s+/g, '_')}.pdf`);
  }
};